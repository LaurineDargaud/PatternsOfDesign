!! Understanding Visitors
@cha:visitors

In a previous chapter we built a simple mathematical expression interpreter.
You were able to build an expression such as (3 + 4) * 5 and then ask the interpreter to compute its value.
The expression trees are similar to the ones that are used to manipulate programs. For example, compilers and code refactorings as offered in Pharo and many modern IDEs are doing such manipulation with trees representing code.
In this chapter we will introduce Visitors. A Visitor is a way to represent an action on a structure (often a tree).
The action can be complex and its embeds its own state and behavior which would be otherwise mixed with the structure.

We will build two simple visitors that evaluate and print an expression.
Let us start with the previous situation.

!!! Existing situation: expression trees

*@fig:ExpressionWithEvaluateWith* shows the simple hierarchy of expressions that we developed in a previous chapter.

+A simple hierarchy of expressions.>file://figures/ExpressionsHierarchyFinal.pdf|width=70|label=fig:ExpressionWithEvaluateWith+


!!! Introducing an Evaluating Visitor
To start we will express the evaluation of an expression but using a visitor, instead of doing it recursively as before. 

We start by adding a method in the Expression class so that any expression can ''welcome'' a visitor and tells it how 
to react.
We add the method ==accept:== as follows: 

[[[
EExpression >> accept: aVisitor

	self subclassResponsibility
]]]

Now we take a concrete case and start with constant.
When the visitor visit a constant, the constant tells the visitor that it should visit the constant as a constant. 
This is literaly what the following method is doing.

[[[
EConstant >> accept: aVisitor

	^ aVisitor visitConstant: self
]]]

!!!! Defining the visitor class
Now it is time to define class representing the evaluating visitor.

[[[
Object subclass: #EEvaluatorVisitor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Expressions-Model'
]]]

Once the class is created we can define what is it to visit a constant expression.
This is simple, it is just to return the constant value. 
We define the ==visitConstant:== as follows: 

[[[
EEvaluatorVisitor >> visitConstant: aConstant

	^ aConstant value
]]]

itunes
!!!! Adding a test class
To make sure that we control what we are doing, we add a test class.

[[[
TestCase subclass: #EEvaluatorVisitorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Expressions-Test'
]]]

We are ready to write our first test

[[[
EEvaluatorVisitorTest >> testVisitConstantReturnsConstantValue

	| constant result |
	constant := EConstant value: 5.
	result := constant accept: EEvaluatorVisitor new.
	self assert: result equals: 5
]]]

We can rewrite the old evaluateWith: method to invoke the visitor.
[[[
EConstant >> evaluateWith: anObject
	
	^ self accept: EEvaluatorVisitor new
]]]

You can execute your new and old tests and both should work.

!!! Now handling addition
We will do the same with adddition.
First we define a new ==accept:== method on the Addition class to invoke the visitor. 

[[[
EAddition >> accept: aVisitor

	^ aVisitor visitAddition: self
]]]

Notice again that the visitor announces itself and that the addition tells him that it should be treated this time as an addition.
This pattern is key to the visitor logic.
You will see that we will repeat again and again.
Each expression will declare how it should considered by the visitor. 

Now we can define a new test to validate that the execution of an addition is correct.

[[[
EEvaluatorVisitorTest >> testVisitAdditionReturnsAdditionResult

	| expression result |
	expression := EAddition
		left: (EConstant value: 7)
		right: (EConstant value: -2).
	result := expression accept: EEvaluatorVisitor new.	
	self assert: result equals: 5
]]]

We start to define an abstract method ==visitAddition:==.

[[[
EEvaluatorVisitor >> visitAddition: anEAddition
	self shouldBeImplemented
]]]

We create the accessors ==left== and ==right==.

[[[
EBinaryExpression >> left
	^ left
]]]

[[[
EBinaryExpression >> right
	^ right
]]]

Now we are ready to define the method ==visitAddition:== as follows:

[[[
EEvaluatorVisitor >> visitAddition: anEAddition
	
	| evaluationOfLeft evaluationOfRight |
	evaluationOfLeft := anEAddition left accept: self.
	evaluationOfRight := anEAddition left accept: self.
	^ evaluationOfLeft + evaluationOfRight
]]]

We also define the method ==evaluateWith:==.

[[[
EAddition >> evaluateWith: anObject
	^ (right evaluateWith: anObject) + (left evaluateWith: anObject)
]]]

!!! Supporting negation

We will now focus on the negation.

[[[
EEvaluatorVisitorTest >> testVisitNegationReturnsNegatedConstant

	| expression result |
	expression := (EConstant value: 7) negated.
	result := expression accept: EEvaluatorVisitor new.
	self assert: result equals: -7
]]]

We follow the same process.
We define the ==accept:== method for the negation.

[[[
ENegation >> accept: aVisitor
	^ aVisitor visitNegation: self
]]]

[[[
EEvaluatorVisitor >> visitNegation: anENegation
	self shouldBeImplemented.
]]]

We add the ==expression== accessor.

[[[
ENegation >> expression
	^ expression
]]]

We define the ==visitNegation:== as follows: 

[[[
EEvaluatorVisitor >> visitNegation: anENegation 

	| aNumber |
	aNumber := anENegation expression accept: self.
	^ aNumber negated
]]]

We can define the ==evaluateWith:== method on a negation to invoke the visitor.

[[[
ENegation >> evaluateWith: anObject
	^ self accept: EEvaluatorVisitor new
]]]

We can also redefine the method ==evaluateWith:== in a more recursive way.

[[[
ENegation >> evaluateWith: anObject
	^ (expression evaluateWith: anObject) negated
]]]


!!! Supporting Multiplication

[[[
EEvaluatorVisitorTest >> testVisitMultiplicationReturnsMultiplicationResult

	| expression result |
	expression := EMultiplication
		left: (EConstant value: 7)
		right: (EConstant value: -2).
	
	result := expression accept: EEvaluatorVisitor new.
	
	self assert: result equals: -14
]]]

[[[
EMultiplication >> accept: anEEvaluatorVisitor 
	self shouldBeImplemented.
]]]

[[[
EMultiplication >> accept: aVisitor
	
	^ aVisitor visitMultiplication: self
]]]

[[[
EEvaluatorVisitor >> visitMultiplication: anEMultiplication 
	self shouldBeImplemented.
]]]

[[[
EEvaluatorVisitor >> visitMultiplication: anEMultiplication 

	| evaluationOfLeft evaluationOfRight |
	evaluationOfLeft := anEMultiplication left accept: self.
	evaluationOfRight := anEMultiplication right accept: self.
	^ evaluationOfLeft * evaluationOfRight
]]]


!!! Supporting Division

[[[
EDivision >> numerator
	^ numerator
]]]

[[[
EDivision >> denominator
	^ denominator
]]]

[[[
EDivision >> accept: aVisitor

	^ aVisitor visitDivision: self
]]]

[[[
EEvaluatorVisitor >> visitDivision: aDivision 

	| denom numerator |
	denom := aDivision denominator accept: self.
	denom isZero
		ifTrue: [ EZeroDenominator signal ].
	numerator := aDivision numerator accept: self. 
	^ numerator / denom
]]]

[[[
EEvaluatorVisitorTest >> testVisitDivisionReturnsDivisionResult

	| expression result |
	expression := EDivision
		numerator: (EConstant value: 6)
		denominator: (EConstant value: 3).
	result := expression accept: EEvaluatorVisitor new.
	self assert: result equals: 2
]]]

[[[
EDivision class >> numerator: aNumeratorExpression denominator: aDenominatorExpression

	^ self new
		numerator: aNumeratorExpression;
		denominator: aDenominatorExpression;
		yourself
]]]


[[[
EEvaluatorVisitorTest >> testVisitDivisionByZeroThrowsException

	| expression result |
	expression := EDivision
		numerator: (EConstant value: 6)
		denominator: (EConstant value: 0).	
	self
		should: [expression accept: EEvaluatorVisitor new]
		raise: EZeroDenominator
]]]

[[[
EEvaluatorVisitorTest >> testVisitDivisionByZeroThrowsException

	| expression  |
	expression := EDivision
		numerator: (EConstant value: 6)
		denominator: (EConstant value: 0).
	
	self
		should: [expression accept: EEvaluatorVisitor new]
		raise: EZeroDenominator
]]]


!!! Supporting variable

[[[
EVariable >> accept: aVisitor
	^ aVisitor visitVariable: self
]]]

[[[
Object subclass: #EEvaluatorVisitor
	instanceVariableNames: 'bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Expressions-Model'
]]]

[[[
EEvaluatorVisitor >> initialize

	super initialize.
	bindings := Dictionary new
]]]

[[[
EEvaluatorVisitor >> visitVariable: aVariable

	^ bindings at: aVariable id
]]]

[[[
EEvaluatorVisitorTest >> testVisitVariableReturnsVariableValue

	| expression result |
	expression := (EVariable id: #answerToTheQuestion) negated.
	result := expression accept: EEvaluatorVisitor new.
	self assert: result equals: 42
]]]

[[[
EVariable class >> id: anId

	^ self new
		id: anId;
		yourself
]]]

[[[
EVariable class >> id: anId

	^ self new
		id: anId;
		yourself
]]]

[[[
EEvaluatorVisitorTest >> testVisitVariableReturnsVariableValue
	| expression result visitor |
	expression := (EVariable id: #answerToTheQuestion) negated.
	visitor := EEvaluatorVisitor new.
	result := expression accept: visitor.
	self assert: result equals: 42
]]]

[[[
EEvaluatorVisitorTest >> testVisitVariableReturnsVariableValue
	| expression result visitor |
	expression := (EVariable id: #answerToTheQuestion) negated.

	visitor := EEvaluatorVisitor new.
	visitor at: #answerToTheQuestion put: 42.
	
	result := expression accept: visitor.
	self assert: result equals: 42
]]]

[[[
EEvaluatorVisitor >> at: anId put: aValue

	bindings at: anId put: aValue
]]]

[[[
EVariable >> id
	^ id
]]]

[[[
EEvaluatorVisitorTest >> testVisitVariableReturnsVariableValue
	| expression result visitor |
	expression := EVariable id: #answerToTheQuestion.

	visitor := EEvaluatorVisitor new.
	visitor at: #answerToTheQuestion put: 42.
	
	result := expression accept: visitor.
	self assert: result equals: 42
]]]

[[[
EDivision >> evaluateWith: anObject
	^ self accept: EEvaluatorVisitor new
]]]

[[[
EMultiplication >> evaluateWith: anObject
	
	^ self accept: EEvaluatorVisitor new
]]]

[[[
EAddition >> evaluateWith: anObject	
	^ self accept: EEvaluatorVisitor new
]]]

[[[
EAddition >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
EConstant >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
EDivision >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
EMultiplication >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
ENegation >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
EVariable >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
EEvaluatorVisitor >> bindings: aDictionary

	bindings := aDictionary
]]]


[[[
EExpression >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]

[[[
EVariable >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]


[[[
EConstant >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]


[[[
EDivision >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]


[[[
ENegation >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]


[[[
EAddition >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]


[[[
EMultiplication >> evaluateWith: anObject

	| visitor |
	visitor := EEvaluatorVisitor new.
	visitor bindings: anObject.
	^ self accept: visitor.
]]]


[[[
EEvaluatorVisitorTest >> testVisitDivisionReturnsDivisionResult

	| expression result |
	expression := EDivision
		numerator: (EConstant value: 6)
		denominator: (EConstant value: 3).
	
	result := expression accept: EEvaluatorVisitor new.
	
	self assert: result equals: 2
]]]


[[[
EEvaluatorVisitor >> visitMultiplication: anEMultiplication 

	| evaluationOfLeft evaluationOfRight |
	evaluationOfLeft := anEMultiplication left accept: self.
	evaluationOfRight := anEMultiplication right accept: self.
	^ evaluationOfLeft * evaluationOfRight
]]]


!!! A new visitor

[[[
Object subclass: #EPrinterVisitor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Expressions-Model'
]]]

[[[
EPrinterVisitor >> visitConstant: aConstant
	^ aConstant value asString
]]]


[[[
EPrinterVisitor >> visitMutiplication: aMultiplication

	| left right |
	left := aMultiplication left accept: self.
	right := aMultiplication right accept: self.
	^ '(', left , ' * ', right, ')'
]]]

[[[
EPrinterVisitor >> visitMultiplication: aMultiplication

	| left right |
	left := aMultiplication left accept: self.
	right := aMultiplication right accept: self.
	^ '(', left , ' * ', right, ')'
]]]

[[[
EPrinterVisitor >> visitMutiplication: aMultiplication

	| left right |
	left := aMultiplication left accept: self.
	right := aMultiplication right accept: self.
	^ '(', left , ' * ', right, ')'
]]]


[[[
EPrinterVisitor >> visitAddition: anAddition

	| left right |
	left := anAddition left accept: self.
	right := anAddition right accept: self.
	^ '(', left , ' + ', right, ')'
]]]

[[[
EPrinterVisitor >> visitDivision: aDivision

	| left right |
	left := aDivision left accept: self.
	right := aDivision right accept: self.
	^ '(', left , ' / ', right, ')'
]]]

[[[
EPrinterVisitor >> visitNegation: aNegation

	| subExpression |
	subExpression := aNegation expression accept: self.
	^ subExpression , ' negated'
]]]

[[[
EPrinterVisitor >> visitVariable: aVariable

	^ aVariable id asString
]]]



!!! Conclusion

say something :)